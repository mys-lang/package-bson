class BsonError(Error):
    message: string

class _Reader:
    _data: bytes
    _pos: i64

    func __init__(self, data: bytes):
        self._data = data
        self._pos = 0

    func available(self) -> bool:
        return self._pos < i64(len(self._data))

    func read_u8(self) -> u8:
        if not self.available():
            raise BsonError("No more data available.")

        value = self._data[self._pos]
        self._pos += 1

        return value

    func read_u16(self) -> u16:
        return u16(self.read_u8()) | (u16(self.read_u8()) << 8)

    func read_u32(self) -> u32:
        return u32(self.read_u16()) | (u32(self.read_u16()) << 16)

    func read_u64(self) -> u64:
        return u64(self.read_u32()) | (u64(self.read_u32()) << 32)

    func read_i8(self) -> i8:
        return i8(self.read_u8())

    func read_i16(self) -> i16:
        return i16(self.read_u16())

    func read_i32(self) -> i32:
        return i32(self.read_u32())

    func read_i64(self) -> i64:
        return i64(self.read_u64())

    func read_f64(self) -> f64:
        value = 0.0
        ivalue = self.read_u64()
        c"memcpy(&value, &ivalue, sizeof(value));"

        return value

    func read_bytes(self, count: i64) -> bytes:
        data = b""

        for _ in range(count):
            data += self.read_u8()

        return data

class _Writer:
    _data: bytes

    func __init__(self):
        self._data = b""

    func data(self) -> bytes:
        return self._data

    func write_i32_at(self, offset: i64, value: i32):
        self._data[offset + 0] = u8(value)
        self._data[offset + 1] = u8(value >> 8)
        self._data[offset + 2] = u8(value >> 16)
        self._data[offset + 3] = u8(value >> 24)

    func write_u8(self, value: u8):
        self._data += value

    func write_u16(self, value: u16):
        self.write_u8(u8(value))
        self.write_u8(u8(value >> 8))

    func write_u32(self, value: u32):
        self.write_u16(u16(value))
        self.write_u16(u16(value >> 16))

    func write_u64(self, value: u64):
        self.write_u32(u32(value))
        self.write_u32(u32(value >> 32))

    func write_i8(self, value: i8):
        self.write_u8(u8(value))

    func write_i16(self, value: i16):
        self.write_u16(u16(value))

    func write_i32(self, value: i32):
        self.write_u32(u32(value))

    func write_i64(self, value: i64):
        self.write_u64(u64(value))

    func write_bytes(self, value: bytes):
        self._data += value

@trait
class Element:
    """An element in a BSON document.

    """

    func get_double(self) -> f64:
        raise NotImplementedError()

    func get_string(self) -> string:
        raise NotImplementedError()

    func get(self, key: string) -> Element:
        raise NotImplementedError()

    func get_binary(self) -> (u8, bytes):
        raise NotImplementedError()

    func get_boolean(self) -> bool:
        raise NotImplementedError()

    func get_i32(self) -> i32:
        raise NotImplementedError()

class Double(Element):
    """A double.

    """

    value: f64

    func get_double(self) -> f64:
        return self.value

class String(Element):
    """A string.

    """

    value: string

    func get_string(self) -> string:
        return self.value

class Document(Element):
    """A document.

    """

    items: {string: Element}

    func __init__(self):
        self.items = {}

    func get(self, key: string) -> Element:
        return self.items[key]

class Array(Element):
    """An array.

    """

    items: [(string, Element)]

    func __init__(self):
        self.items = []

    func at(self, pos: i64) -> (string, Element):
        return self.items[pos]

class Binary(Element):
    """A binary blob.

    """

    value: (u8, bytes)

    func get_binary(self) -> (u8, bytes):
        return self.value

class Boolean(Element):
    """A boolean.

    """

    value: bool

    func get_boolean(self) -> bool:
        return self.value

class Int32(Element):
    """An i32.

    """

    value: i32

    func get_i32(self) -> i32:
        return self.value

func _decode_cstring(reader: _Reader) -> string:
    data = b""

    while True:
        value = reader.read_u8()

        if value == 0:
            break

        data += value

    return string(data)

func _decode_double(reader: _Reader) -> Double:
    return Double(reader.read_f64())

func _decode_string(reader: _Reader) -> String:
    length = reader.read_i32()
    element = String(string(reader.read_bytes(i64(length - 1))))
    reader.read_u8()

    return element

func _decode_document(reader: _Reader) -> Document:
    reader.read_i32()
    document = Document()

    while True:
        kind = reader.read_u8()

        if kind == 0:
            break

        name = _decode_cstring(reader)
        element: Element = None

        match kind:
            case 1:
                element = _decode_double(reader)
            case 2:
                element = _decode_string(reader)
            case 3:
                element = _decode_document(reader)
            case 5:
                element = _decode_binary(reader)
            case 8:
                element = _decode_boolean(reader)
            case 16:
                element = _decode_i32(reader)
            case _:
                raise BsonError(f"Bad kind {kind}.")

        document.items[name] = element

    return document

func _decode_binary(reader: _Reader) -> Binary:
    length = reader.read_i32()
    subtype = reader.read_u8()
    data = reader.read_bytes(i64(length))

    return Binary((subtype, data))

func _decode_boolean(reader: _Reader) -> Boolean:
    return Boolean(reader.read_u8() == 1)

func _decode_i32(reader: _Reader) -> Int32:
    return Int32(reader.read_i32())

func decode(data: bytes) -> Document:
    """Decode given BSON document.

    """

    return _decode_document(_Reader(data))

func encode(document: Document) -> bytes:
    """Encode given BSON document.

    """

    writer = _Writer()
    writer.write_i32(0)

    for name, element in document.items:
        match element:
            case String() as string_element:
                writer.write_u8(2)
                writer.write_bytes(name.to_utf8())
                writer.write_u8(0)
                value = string_element.get_string().to_utf8()
                writer.write_i32(i32(len(value)) + 1)
                writer.write_bytes(value)
                writer.write_u8(0)
            case Int32() as int32_element:
                writer.write_u8(16)
                writer.write_bytes(name.to_utf8())
                writer.write_u8(0)
                writer.write_i32(int32_element.get_i32())
            case _:
                raise BsonError("Bad element.")

    writer.write_u8(0)
    writer.write_i32_at(0, i32(len(writer.data())))

    return writer.data()

@test
func test_small_mongodb():
    encoded = (
        b"\x24\x00\x00\x00"
        b"\x10" b"whatsmyuri\x00" b"\x01\x00\x00\x00"
        b"\x02" b"$db\x00" b"\x06\x00\x00\x00" b"admin\x00"
        b"\x00")

    document = decode(encoded)
    assert document.get("whatsmyuri").get_i32() == 1
    assert document.get("$db").get_string() == "admin"

    encoded_swapped = (
        b"\x24\x00\x00\x00"
        b"\x02" b"$db\x00" b"\x06\x00\x00\x00" b"admin\x00"
        b"\x10" b"whatsmyuri\x00" b"\x01\x00\x00\x00"
        b"\x00")

    assert encode(document) in [encoded, encoded_swapped]

@test
func test_mongodb_list_databases():
    encoded = (
        b"\x5a\x00\x00\x00\x01\x6c\x69\x73\x74\x44\x61\x74\x61\x62\x61\x73"
        b"\x65\x73\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x08\x6e\x61\x6d\x65"
        b"\x4f\x6e\x6c\x79\x00\x00\x03\x6c\x73\x69\x64\x00\x1e\x00\x00\x00"
        b"\x05\x69\x64\x00\x10\x00\x00\x00\x04\xfb\xe9\x2e\x09\xc9\xc8\x45"
        b"\x09\xa8\x01\x1d\x0f\x73\xe5\xf7\x46\x00\x02\x24\x64\x62\x00\x06"
        b"\x00\x00\x00\x61\x64\x6d\x69\x6e\x00\x00")

    document = decode(encoded)
    print(document)
    assert document.get("listDatabases").get_double() == 1.0
    assert not document.get("nameOnly").get_boolean()
    assert document.get("lsid").get("id").get_binary() == (
        4,
        b"\xfb\xe9\x2e\x09\xc9\xc8\x45\x09\xa8\x01\x1d\x0f\x73\xe5\xf7\x46")
    assert document.get("$db").get_string() == "admin"

    # encoded_swapped = (
    #     b"\x24\x00\x00\x00"
    #     b"\x02" b"$db\x00" b"\x06\x00\x00\x00" b"admin\x00"
    #     b"\x10" b"whatsmyuri\x00" b"\x01\x00\x00\x00"
    #     b"\x00")
    #
    # assert encode(document) in [encoded, encoded_swapped]
